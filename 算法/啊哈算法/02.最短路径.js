// 最短路径--动态规划的思想
// Floyd-Warshall算法是解决任意两点间的最短路径的一种算法。
// 通常可以在任何图中使用，包括有向图、带负权边的图。  算法的时间复杂度为O（N^3）
// 该算法不能解决带有“负权回路”（或者叫“负权环”）的图。因为这类型的图没有最短路径

var k, i, j, t1, t2, t3
var inf = 999999
var n = 4 // 表示4个点
var m = 8 // 表示4个点之间所有边之和
var e = [[], [], [], [], []]

// 初始化--默认点与点之间都有边，且距离为inf（无穷大）
for (i = 1; i <= n ; i++) {
  for (j = 1; j <= n; j++) {
    if (i === j) {
      e[i][j] = 0 // 表示 始点和终点相同的时候，距离为0
    } else {
      e[i][j] = inf // 表示 从i点到j点的距离为inf（无穷大）
    }
  }
}

// 给部分点与点之间设置边以及距离
e[1][2] = 2 // 表示 从1点 到 2点 的距离为 2
e[1][3] = 6 // 表示 从1点 到 3点 的距离为 6
e[1][4] = 4 // 表示 从1点 到 4点 的距离为 4
e[2][3] = 3 // 表示 从2点 到 3点 的距离为 3
e[3][1] = 7 // 表示 从3点 到 1点 的距离为 7
e[3][4] = 1 // 表示 从3点 到 4点 的距离为 1
e[4][1] = 5 // 表示 从4点 到 1点 的距离为 5
e[4][3] = 12 // 表示 从4点 到 3点 的距离为 12

// 最短路径--算法核心语句
for (k = 1; k <= n; k++) {
  for (i = 1; i <= n; i++) {
    for (j = 1; j <= n; j++) {
      if ((e[i][k] < inf) && (e[k][j] < inf) && (e[i][j] > e[i][k] + e[k][j])) {
        e[i][j] = e[i][k] + e[k][j]
      }
    }
  }
}

// 输出结果
for (i = 1; i<= n; i++) {
  for (j = 1; j <= n; j++) {
    console.log('从' + i + '点到' + j + '点的最短距离为' + e[i][j])
    console.log('-----------------------------------------------')
  }
}

console.log(e)
