// 存放每个节点的根节点
var f = []

// 记录节点的个数
var n = 10

// 有关联的节点关系
var m = []
m.length = 10
m[1] = [1, 2]
m[2] = [3, 4]
m[3] = [5, 2]
m[4] = [4, 6]
m[5] = [2, 6]
m[6] = [8, 7]
m[7] = [9, 7]
m[8] = [1, 6]
m[9] = [2, 4]

// 记录独立根节点的个数
var sum = 0

// 初始化 数组里 存的是 自己数组下标的编号
function init () {
  for (let i = 1; i <= n; i++) {
    f[i] = i
  }
}

// 找祖宗的递归函数，不停地去找祖宗，直到找到祖宗为止，
// 其实就是去找犯罪团伙的最高领导人，“擒贼先擒王”原则
function getF (v) {
  if (f[v] === v) {
    return v
  } else {
    // 这里是路径压缩，每次在函数返回的时候，顺带把路上遇到的人的“BOSS”改为最后
    // 找到的祖宗编号，也就是犯罪团伙的最高领导人编号。这样可以提高今后找到犯罪团伙的最高领导人
    //（其实就是树的祖先）的速度
    f[v] = getF(f[v])
    return f[v]
  }
}
// 合并两子集合的函数
function merge (v, u) {
  let t1, t2
  t1 = getF(v)
  t2 = getF(u)
  if (t1 !== t2) {  // 判断两个节点是否在同一个集合中，即是否为同一个祖先
    f[t2] = t1
    // “靠左”原则左边变成右边的BOSS。即把右边的集合，作为左边集合的子集合。
    // 经过路径压缩后，将f[u]的根的值也赋值为v的祖先f[t1]
  }
}

// 初始化
init()
// 开始合并犯罪团伙
for (let i = 1; i < m.length; i++) {
  merge(m[i][0], m[i][1])
}
// 求出独立的根节点,即扫描出有多少个独立的犯罪团伙
for (let i = 1; i <= n; i++) {
  if (f[i] === i) {
    sum++
  }
}

console.log(sum)  // 3
